<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API: OpenSim::Property&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="MathJax-2.7.0/MathJax.js"></script>
<link href="doxygen_user.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenSimLogoWhiteHorizontal_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API
   &#160;<span id="projectnumber">4.5-2024-01-10-34fd6af0b</span>
   </div>
   <div id="projectbrief">For MATLAB, Python, Java, and C++ users</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classOpenSim_1_1Property.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classOpenSim_1_1Property-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenSim::Property&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T.  
 <a href="classOpenSim_1_1Property.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for OpenSim::Property&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classOpenSim_1_1Property.png" usemap="#OpenSim::Property_3C_20T_20_3E_map" alt=""/>
  <map id="OpenSim::Property_3C_20T_20_3E_map" name="OpenSim::Property_3C_20T_20_3E_map">
<area href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va..." alt="OpenSim::AbstractProperty" shape="rect" coords="0,0,165,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeeca88c50f8115970c150889b1fd1ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aeeca88c50f8115970c150889b1fd1ab3">clone</a> () const override=0</td></tr>
<tr class="memdesc:aeeca88c50f8115970c150889b1fd1ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space.  <a href="#aeeca88c50f8115970c150889b1fd1ab3">More...</a><br /></td></tr>
<tr class="separator:aeeca88c50f8115970c150889b1fd1ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d2d8a31105c18755a6a12a0ec955a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a504d2d8a31105c18755a6a12a0ec955a">getTypeName</a> () const override final</td></tr>
<tr class="memdesc:a504d2d8a31105c18755a6a12a0ec955a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html" title="This is the generic definition of Property::TypeHelper to be used whenever T does not have a speciali...">TypeHelper</a>'s <a class="el" href="classOpenSim_1_1Property.html#a504d2d8a31105c18755a6a12a0ec955a" title="Use TypeHelper&#39;s getTypeName() to satisfy this pure virtual. ">getTypeName()</a> to satisfy this pure virtual.  <a href="#a504d2d8a31105c18755a6a12a0ec955a">More...</a><br /></td></tr>
<tr class="separator:a504d2d8a31105c18755a6a12a0ec955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7af7802a58607ab6a41c73e23f916c"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a3d7af7802a58607ab6a41c73e23f916c">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:a3d7af7802a58607ab6a41c73e23f916c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to one of the values in the value list.  <a href="#a3d7af7802a58607ab6a41c73e23f916c">More...</a><br /></td></tr>
<tr class="separator:a3d7af7802a58607ab6a41c73e23f916c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d26efb726367aca90f2534b032352"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a567d26efb726367aca90f2534b032352">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a567d26efb726367aca90f2534b032352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to one of the values in the value list.  <a href="#a567d26efb726367aca90f2534b032352">More...</a><br /></td></tr>
<tr class="separator:a567d26efb726367aca90f2534b032352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c23999672ed5ec0d74d140a67e89ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aa9c23999672ed5ec0d74d140a67e89ea">operator=</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa9c23999672ed5ec0d74d140a67e89ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a value of type T sets the value of this single-valued property to a copy of the supplied <em>value</em>; not allowed for a list property.  <a href="#aa9c23999672ed5ec0d74d140a67e89ea">More...</a><br /></td></tr>
<tr class="separator:aa9c23999672ed5ec0d74d140a67e89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Container&gt; </td></tr>
<tr class="memitem:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#af3f1f6ba165cb5bd24cab98a22a8076c">operator=</a> (const Container&lt; T &gt; &amp;valueList)</td></tr>
<tr class="memdesc:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container.  <a href="#af3f1f6ba165cb5bd24cab98a22a8076c">More...</a><br /></td></tr>
<tr class="separator:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">setValue</a> (int i, const T &amp;value)</td></tr>
<tr class="memdesc:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the i'th value list element with a copy of the given <em>value</em>.  <a href="#a3a8b68f9fa4cf67c5b9d681b4499d63e">More...</a><br /></td></tr>
<tr class="separator:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92e55af5a211a210900438d858a481a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aa92e55af5a211a210900438d858a481a">setValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa92e55af5a211a210900438d858a481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a new value for a single-valued property.  <a href="#aa92e55af5a211a210900438d858a481a">More...</a><br /></td></tr>
<tr class="separator:aa92e55af5a211a210900438d858a481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00355490194329012905b3407917fe9e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Container&gt; </td></tr>
<tr class="memitem:a00355490194329012905b3407917fe9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a00355490194329012905b3407917fe9e">setValue</a> (const Container&lt; T &gt; &amp;valueList)</td></tr>
<tr class="memdesc:a00355490194329012905b3407917fe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container.  <a href="#a00355490194329012905b3407917fe9e">More...</a><br /></td></tr>
<tr class="separator:a00355490194329012905b3407917fe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad655c37b8c73982b61714965285d4ca9"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ad655c37b8c73982b61714965285d4ca9">getValue</a> (int index=-1) const</td></tr>
<tr class="memdesc:ad655c37b8c73982b61714965285d4ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the selected value from this property's value list.  <a href="#ad655c37b8c73982b61714965285d4ca9">More...</a><br /></td></tr>
<tr class="separator:ad655c37b8c73982b61714965285d4ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae597340fa1da9385439bbebf91a6a92a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ae597340fa1da9385439bbebf91a6a92a">updValue</a> (int index=-1)</td></tr>
<tr class="memdesc:ae597340fa1da9385439bbebf91a6a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the selected value from this property's value list.  <a href="#ae597340fa1da9385439bbebf91a6a92a">More...</a><br /></td></tr>
<tr class="separator:ae597340fa1da9385439bbebf91a6a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">appendValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a copy of the supplied <em>value</em> to the end of this property's value list.  <a href="#a8cebe3dfc74cb4f1d5158a4feb449e05">More...</a><br /></td></tr>
<tr class="separator:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7f8d2992c9f493380aa3400a6f6ec9a8">appendValue</a> (const T *value)</td></tr>
<tr class="memdesc:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a <em>copy</em> of the supplied <em>value</em> to the end of this property's value list.  <a href="#a7f8d2992c9f493380aa3400a6f6ec9a8">More...</a><br /></td></tr>
<tr class="separator:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f955ce364fd5c6a031263894a77c6a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7f955ce364fd5c6a031263894a77c6a2">adoptAndAppendValue</a> (T *value)</td></tr>
<tr class="memdesc:a7f955ce364fd5c6a031263894a77c6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new value to the end of this property's value list, taking over ownership of the supplied heap-allocated object.  <a href="#a7f955ce364fd5c6a031263894a77c6a2">More...</a><br /></td></tr>
<tr class="separator:a7f955ce364fd5c6a031263894a77c6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648a457cc3c192dcb68a97a6e179e2db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a648a457cc3c192dcb68a97a6e179e2db">removeValueAtIndex</a> (int index)</td></tr>
<tr class="memdesc:a648a457cc3c192dcb68a97a6e179e2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove specific entry of the list at index.  <a href="#a648a457cc3c192dcb68a97a6e179e2db">More...</a><br /></td></tr>
<tr class="separator:a648a457cc3c192dcb68a97a6e179e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23afa22d5e9e646e7da341dcee0399b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ad23afa22d5e9e646e7da341dcee0399b">findIndex</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:ad23afa22d5e9e646e7da341dcee0399b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the value list for an element that has the given <em>value</em> and return its index if found, otherwise -1.  <a href="#ad23afa22d5e9e646e7da341dcee0399b">More...</a><br /></td></tr>
<tr class="separator:ad23afa22d5e9e646e7da341dcee0399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f59bebcc0e0665781b238505312667"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#af4f59bebcc0e0665781b238505312667">findIndexForName</a> (const SimTK::String &amp;name) const =0</td></tr>
<tr class="memdesc:af4f59bebcc0e0665781b238505312667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return index of passed in name if the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> contains objects that are derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, and -1 if no such <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> is found.  <a href="#af4f59bebcc0e0665781b238505312667">More...</a><br /></td></tr>
<tr class="separator:af4f59bebcc0e0665781b238505312667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classOpenSim_1_1AbstractProperty"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classOpenSim_1_1AbstractProperty')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classOpenSim_1_1AbstractProperty.html">OpenSim::AbstractProperty</a></td></tr>
<tr class="memitem:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">setAllowableListSize</a> (int aMin, int aMax)</td></tr>
<tr class="memdesc:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that the number of values n in the value list of this property be in the range aMin &lt;= n &lt;= aMax.  <a href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">More...</a><br /></td></tr>
<tr class="separator:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a26c9f2020339f49a08a9a3a3a37adc5f">setAllowableListSize</a> (int aNum)</td></tr>
<tr class="memdesc:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that the number of values n in the value list of this property be exactly n=aNum values.  <a href="classOpenSim_1_1AbstractProperty.html#a26c9f2020339f49a08a9a3a3a37adc5f">More...</a><br /></td></tr>
<tr class="separator:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aab21326774230e4921d6e912bbb1bb71">~AbstractProperty</a> ()</td></tr>
<tr class="memdesc:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all heap space used by this property.  <a href="classOpenSim_1_1AbstractProperty.html#aab21326774230e4921d6e912bbb1bb71">More...</a><br /></td></tr>
<tr class="separator:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385fae988f5d035ef20ad80f61c65cc7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a385fae988f5d035ef20ad80f61c65cc7">toString</a> () const =0</td></tr>
<tr class="memdesc:a385fae988f5d035ef20ad80f61c65cc7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For relatively simple types, return the current value of this property in a string suitable for displaying to a user in the GUI (i.e., this number may be rounded and not an exact representation of the actual value being used).  <a href="classOpenSim_1_1AbstractProperty.html#a385fae988f5d035ef20ad80f61c65cc7">More...</a><br /></td></tr>
<tr class="separator:a385fae988f5d035ef20ad80f61c65cc7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea10289debd97d3a1087b0ddbd2bbb07 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aea10289debd97d3a1087b0ddbd2bbb07">toStringForDisplay</a> (const int precision) const</td></tr>
<tr class="memdesc:aea10289debd97d3a1087b0ddbd2bbb07 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For relatively simple types, return the current value of this property in a string suitable for displaying to a user in the GUI (i.e., this number may be rounded and not an exact representation of the actual value being used).  <a href="classOpenSim_1_1AbstractProperty.html#aea10289debd97d3a1087b0ddbd2bbb07">More...</a><br /></td></tr>
<tr class="separator:aea10289debd97d3a1087b0ddbd2bbb07 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478982e93cc5ad89e447b03e4aa48a5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a2478982e93cc5ad89e447b03e4aa48a5">isObjectProperty</a> () const =0</td></tr>
<tr class="memdesc:a2478982e93cc5ad89e447b03e4aa48a5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an "object property", meaning that its values are all concrete objects of types that ultimately derive from the OpenSim serializable base class <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="classOpenSim_1_1AbstractProperty.html#a2478982e93cc5ad89e447b03e4aa48a5">More...</a><br /></td></tr>
<tr class="separator:a2478982e93cc5ad89e447b03e4aa48a5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12b01d2c439e87470bd230c1061fab8 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ad12b01d2c439e87470bd230c1061fab8">isUnnamedProperty</a> () const =0</td></tr>
<tr class="memdesc:ad12b01d2c439e87470bd230c1061fab8 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unnamed property is a one-object property whose name was given as null or as the contained object's type tag.  <a href="classOpenSim_1_1AbstractProperty.html#ad12b01d2c439e87470bd230c1061fab8">More...</a><br /></td></tr>
<tr class="separator:ad12b01d2c439e87470bd230c1061fab8 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1343f7d7a5c88d008db435ee44bc869 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ad1343f7d7a5c88d008db435ee44bc869">equals</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const</td></tr>
<tr class="memdesc:ad1343f7d7a5c88d008db435ee44bc869 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this property with another one; this is primarily used for testing.  <a href="classOpenSim_1_1AbstractProperty.html#ad1343f7d7a5c88d008db435ee44bc869">More...</a><br /></td></tr>
<tr class="separator:ad1343f7d7a5c88d008db435ee44bc869 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f4d355d682e7d0cf4ec33e7a3553de inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a68f4d355d682e7d0cf4ec33e7a3553de">isSamePropertyClass</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const</td></tr>
<tr class="memdesc:a68f4d355d682e7d0cf4ec33e7a3553de inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the <em>other</em> property is an object of exactly the same concrete class as this one.  <a href="classOpenSim_1_1AbstractProperty.html#a68f4d355d682e7d0cf4ec33e7a3553de">More...</a><br /></td></tr>
<tr class="separator:a68f4d355d682e7d0cf4ec33e7a3553de inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26105c68088639cfac2a55206c6a9e65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a26105c68088639cfac2a55206c6a9e65">operator==</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const</td></tr>
<tr class="memdesc:a26105c68088639cfac2a55206c6a9e65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the <a class="el" href="classOpenSim_1_1AbstractProperty.html#ad1343f7d7a5c88d008db435ee44bc869" title="Compare this property with another one; this is primarily used for testing. ">equals()</a> method for the meaning of this operator.  <a href="classOpenSim_1_1AbstractProperty.html#a26105c68088639cfac2a55206c6a9e65">More...</a><br /></td></tr>
<tr class="separator:a26105c68088639cfac2a55206c6a9e65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ab47ef97b89f66793a42c7712275938b5">setAllPropertiesUseDefault</a> (bool shouldUseDefault)</td></tr>
<tr class="memdesc:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the "use default" flag for this property and the properties of any objects it contains to the given value.  <a href="classOpenSim_1_1AbstractProperty.html#ab47ef97b89f66793a42c7712275938b5">More...</a><br /></td></tr>
<tr class="separator:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ae2f988432f0ac82f5e4c787879c16b3e">readFromXMLParentElement</a> (SimTK::Xml::Element &amp;parent, int versionNumber)</td></tr>
<tr class="memdesc:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an XML parent element expected to contain a value for this property as an immediate child element, find that property element and set the property value from it.  <a href="classOpenSim_1_1AbstractProperty.html#ae2f988432f0ac82f5e4c787879c16b3e">More...</a><br /></td></tr>
<tr class="separator:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3ebd934bc118f3422ced85b5990f70 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a2d3ebd934bc118f3422ced85b5990f70">writeToXMLParentElement</a> (SimTK::Xml::Element &amp;parent) const</td></tr>
<tr class="memdesc:a2d3ebd934bc118f3422ced85b5990f70 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an XML parent element, append a single child element representing the serialized form of this property.  <a href="classOpenSim_1_1AbstractProperty.html#a2d3ebd934bc118f3422ced85b5990f70">More...</a><br /></td></tr>
<tr class="separator:a2d3ebd934bc118f3422ced85b5990f70 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#af29bdc3ab4adbbfe954aed4a0780bee7">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property name.  <a href="classOpenSim_1_1AbstractProperty.html#af29bdc3ab4adbbfe954aed4a0780bee7">More...</a><br /></td></tr>
<tr class="separator:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">setComment</a> (const std::string &amp;aComment)</td></tr>
<tr class="memdesc:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a user-friendly comment to be associated with property.  <a href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">More...</a><br /></td></tr>
<tr class="separator:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">setValueIsDefault</a> (bool isDefault)</td></tr>
<tr class="memdesc:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag indicating whether the value of this property was simply taken from a default object and thus should not be written out when serializing.  <a href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">More...</a><br /></td></tr>
<tr class="separator:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da380c1f75c9f87cfd930e773aed4ad inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">getName</a> () const</td></tr>
<tr class="memdesc:a8da380c1f75c9f87cfd930e773aed4ad inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property name.  <a href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">More...</a><br /></td></tr>
<tr class="separator:a8da380c1f75c9f87cfd930e773aed4ad inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862facc6c0b005266819332626dfacc5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a862facc6c0b005266819332626dfacc5">getComment</a> () const</td></tr>
<tr class="memdesc:a862facc6c0b005266819332626dfacc5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comment associated with this property.  <a href="classOpenSim_1_1AbstractProperty.html#a862facc6c0b005266819332626dfacc5">More...</a><br /></td></tr>
<tr class="separator:a862facc6c0b005266819332626dfacc5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3bc39f66b759a8a807429161576ad1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ade3bc39f66b759a8a807429161576ad1">getValueIsDefault</a> () const</td></tr>
<tr class="memdesc:ade3bc39f66b759a8a807429161576ad1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flag indicating whether the current value is just the default value for this property (in which case it doesn't need to be written out).  <a href="classOpenSim_1_1AbstractProperty.html#ade3bc39f66b759a8a807429161576ad1">More...</a><br /></td></tr>
<tr class="separator:ade3bc39f66b759a8a807429161576ad1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f536d90bb3e5f400e540db08511f096 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5f536d90bb3e5f400e540db08511f096">getMinListSize</a> () const</td></tr>
<tr class="memdesc:a5f536d90bb3e5f400e540db08511f096 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum number of values allowed in this property's value list.  <a href="classOpenSim_1_1AbstractProperty.html#a5f536d90bb3e5f400e540db08511f096">More...</a><br /></td></tr>
<tr class="separator:a5f536d90bb3e5f400e540db08511f096 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6da1b1f16d4e9c230487193979298 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">getMaxListSize</a> () const</td></tr>
<tr class="memdesc:ac8e6da1b1f16d4e9c230487193979298 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of values allowed in this property's value list.  <a href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">More...</a><br /></td></tr>
<tr class="separator:ac8e6da1b1f16d4e9c230487193979298 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc70adbf3a2a0fe683b9ffbdcfc52bfc inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#abc70adbf3a2a0fe683b9ffbdcfc52bfc">isOptionalProperty</a> () const</td></tr>
<tr class="memdesc:abc70adbf3a2a0fe683b9ffbdcfc52bfc inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an "optional" property if its value list can contain at most one value.  <a href="classOpenSim_1_1AbstractProperty.html#abc70adbf3a2a0fe683b9ffbdcfc52bfc">More...</a><br /></td></tr>
<tr class="separator:abc70adbf3a2a0fe683b9ffbdcfc52bfc inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f70dd571c232d2a9f7ab64406499e88 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a7f70dd571c232d2a9f7ab64406499e88">isListProperty</a> () const</td></tr>
<tr class="memdesc:a7f70dd571c232d2a9f7ab64406499e88 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "list" property if its value list can contain more than one value.  <a href="classOpenSim_1_1AbstractProperty.html#a7f70dd571c232d2a9f7ab64406499e88">More...</a><br /></td></tr>
<tr class="separator:a7f70dd571c232d2a9f7ab64406499e88 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caab24d637ef7f88244c97bb5ce8ffe inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a1caab24d637ef7f88244c97bb5ce8ffe">isOneValueProperty</a> () const</td></tr>
<tr class="memdesc:a1caab24d637ef7f88244c97bb5ce8ffe inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "one-value" property if its value list must always contain exactly one value.  <a href="classOpenSim_1_1AbstractProperty.html#a1caab24d637ef7f88244c97bb5ce8ffe">More...</a><br /></td></tr>
<tr class="separator:a1caab24d637ef7f88244c97bb5ce8ffe inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae968e7a8df7fbabf28dc6f168d5ca134 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ae968e7a8df7fbabf28dc6f168d5ca134">isOneObjectProperty</a> () const</td></tr>
<tr class="memdesc:ae968e7a8df7fbabf28dc6f168d5ca134 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "one-object" property if it is a "one-value" property and it contains an Object-derived value.  <a href="classOpenSim_1_1AbstractProperty.html#ae968e7a8df7fbabf28dc6f168d5ca134">More...</a><br /></td></tr>
<tr class="separator:ae968e7a8df7fbabf28dc6f168d5ca134 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7505a815a881580e46b84c260654a2c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ad7505a815a881580e46b84c260654a2c">size</a> () const</td></tr>
<tr class="memdesc:ad7505a815a881580e46b84c260654a2c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of values currently in this property's value list.  <a href="classOpenSim_1_1AbstractProperty.html#ad7505a815a881580e46b84c260654a2c">More...</a><br /></td></tr>
<tr class="separator:ad7505a815a881580e46b84c260654a2c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27428a81d54724a7ba0c6a3cb187a75 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ac27428a81d54724a7ba0c6a3cb187a75">empty</a> () const</td></tr>
<tr class="memdesc:ac27428a81d54724a7ba0c6a3cb187a75 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this property's value list is currently empty.  <a href="classOpenSim_1_1AbstractProperty.html#ac27428a81d54724a7ba0c6a3cb187a75">More...</a><br /></td></tr>
<tr class="separator:ac27428a81d54724a7ba0c6a3cb187a75 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5ec8c00426c6841139be00515e749713">clear</a> ()</td></tr>
<tr class="memdesc:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the value list for this property; fails if zero is not an allowable size for this property.  <a href="classOpenSim_1_1AbstractProperty.html#a5ec8c00426c6841139be00515e749713">More...</a><br /></td></tr>
<tr class="separator:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed651c70584d597daa389f197eb5ebd5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aed651c70584d597daa389f197eb5ebd5">getValueAsObject</a> (int index=-1) const =0</td></tr>
<tr class="memdesc:aed651c70584d597daa389f197eb5ebd5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an object property, the values can be obtained as references to the abstract base class <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> from which all the objects derive.  <a href="classOpenSim_1_1AbstractProperty.html#aed651c70584d597daa389f197eb5ebd5">More...</a><br /></td></tr>
<tr class="separator:aed651c70584d597daa389f197eb5ebd5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ac66ced70e8820a21c6f0f4c90f155aff">updValueAsObject</a> (int index=-1)=0</td></tr>
<tr class="memdesc:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get writable access to an existing object value.  <a href="classOpenSim_1_1AbstractProperty.html#ac66ced70e8820a21c6f0f4c90f155aff">More...</a><br /></td></tr>
<tr class="separator:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ab9a11f2382a5216af4dbe49209e7ccef">setValueAsObject</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;obj, int index=-1)=0</td></tr>
<tr class="memdesc:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indicated value element to a new copy of the supplied object.  <a href="classOpenSim_1_1AbstractProperty.html#ab9a11f2382a5216af4dbe49209e7ccef">More...</a><br /></td></tr>
<tr class="separator:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9635d07249fbd05ce8c1fe0d751aec35 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9635d07249fbd05ce8c1fe0d751aec35 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a9635d07249fbd05ce8c1fe0d751aec35">getValue</a> (int index=-1) const</td></tr>
<tr class="memdesc:a9635d07249fbd05ce8c1fe0d751aec35 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the values in this property as type T; this works only if the underlying concrete property stores type T and if the indexed element is present, otherwise throws an exception.  <a href="classOpenSim_1_1AbstractProperty.html#a9635d07249fbd05ce8c1fe0d751aec35">More...</a><br /></td></tr>
<tr class="separator:a9635d07249fbd05ce8c1fe0d751aec35 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a08cd08421dc135dface6cb9fb3d1e1c1">updValue</a> (int index=-1)</td></tr>
<tr class="memdesc:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to one of the values in this property as type T; this works only if the underlying concrete property is actually of type T and the indexed element is present.  <a href="classOpenSim_1_1AbstractProperty.html#a08cd08421dc135dface6cb9fb3d1e1c1">More...</a><br /></td></tr>
<tr class="separator:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a05726a6ab0bee46b8f2b07a8931fd90a">appendValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new value of type T to the end of the list of values currently contained in this property.  <a href="classOpenSim_1_1AbstractProperty.html#a05726a6ab0bee46b8f2b07a8931fd90a">More...</a><br /></td></tr>
<tr class="separator:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432c98206f8a695119818f45a0c75204 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a432c98206f8a695119818f45a0c75204">assign</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;that)=0</td></tr>
<tr class="memdesc:a432c98206f8a695119818f45a0c75204 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign (copy) property <em>that</em> to this object.  <a href="classOpenSim_1_1AbstractProperty.html#a432c98206f8a695119818f45a0c75204">More...</a><br /></td></tr>
<tr class="separator:a432c98206f8a695119818f45a0c75204 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7a234feb91cb9e416ceaaff20586b17b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b">isA</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:a7a234feb91cb9e416ceaaff20586b17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> references a concrete property of this type (Property&lt;T&gt;).  <a href="#a7a234feb91cb9e416ceaaff20586b17b">More...</a><br /></td></tr>
<tr class="separator:a7a234feb91cb9e416ceaaff20586b17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9729da476501b3fb9cfcdcf16f531e7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ac9729da476501b3fb9cfcdcf16f531e7">getAs</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:ac9729da476501b3fb9cfcdcf16f531e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a concrete property of this type (Property&lt;T&gt;).  <a href="#ac9729da476501b3fb9cfcdcf16f531e7">More...</a><br /></td></tr>
<tr class="separator:ac9729da476501b3fb9cfcdcf16f531e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ac416f4ac135fcadc1a35b47b3cd36f0b">updAs</a> (<a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a writable concrete property of this type (Property&lt;T&gt;).  <a href="#ac416f4ac135fcadc1a35b47b3cd36f0b">More...</a><br /></td></tr>
<tr class="separator:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description </h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class OpenSim::Property&lt; T &gt;</h3>

<p>A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T. </p>
<p>The number of values allowed in the list is an attribute of the property; often it is just a single value. Properties are owned by classes that derive from OpenSim's serializable <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> base class. The documentation here is most useful for developers who are interested in creating a new <a class="el" href="classOpenSim_1_1Component.html" title="The abstract Component class defines the interface used to add computational elements to the underlyi...">Component</a>, <a class="el" href="classOpenSim_1_1ModelComponent.html" title="This defines the abstract ModelComponent class, which is used to specify components of a musculoskele...">ModelComponent</a>, or other serializable class derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.</p>
<p>A property's contained type T must be a serializable type. Serializable types come in two flavors:</p><ul>
<li>simple types (like int or string) for which serialization instructions have been provided, and</li>
<li>object types, in which case type T derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> and knows how to serialize itself.</li>
</ul>
<p>When T is a simple type we'll write T=S and refer to a Property&lt;S&gt; as a "simple property". When T is an object type, we'll write T=O and refer to a Property&lt;O&gt; as an "object property".</p>
<p>In case type O is a still-abstract Object-derived type like <a class="el" href="classOpenSim_1_1Function.html" title="An abstract class for representing a function. ">Function</a> or <a class="el" href="classOpenSim_1_1Controller.html" title="Controller is an abstract ModelComponent that defines the interface for  an OpenSim Controller...">Controller</a>, a Property&lt;O&gt; can hold a mix of any concrete objects derived from O (e.g., any <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> that can be dynamic_cast to a <a class="el" href="classOpenSim_1_1Function.html" title="An abstract class for representing a function. ">Function</a> can be held by a Property&lt;<a class="el" href="classOpenSim_1_1Function.html" title="An abstract class for representing a function. ">Function</a>&gt;).</p>
<p>The objects in an object property will themselves have properties so a Property&lt;O&gt; can be viewed as a node in the tree of objects that constitute an OpenSim <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model. ">Model</a>. Simple properties Property&lt;S&gt; can be viewed as the terminal nodes of that tree. Properties are thus an integral part of the structure of an OpenSim <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model. ">Model</a>; anything contained in a property is owned by that property; deleting the property deletes its contained objects. If you want to <em>reference</em> another <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> from within a property, use a string property to reference it by name; the result is a simple property. It is not permitted for type T to be a pointer or reference.</p>
<h3>XML file representation of properties</h3>
<p>The general representation for a Property&lt;T&gt; with name "prop_name" is </p><div class="fragment"><div class="line">&lt;prop_name&gt; T T ... T &lt;/prop_name&gt;</div></div><!-- fragment --><p> where "T" is the XML representation for objects of type T. Note that if T is an object type O, its representation follows the pattern </p><div class="fragment"><div class="line">&lt;OTypeName&gt; OContents &lt;/OTypeName&gt;</div></div><!-- fragment --><p> where <code>OTypeName</code> stands for the name of the concrete, Object-derived class being serialized, and <code>OContents</code> is the representation generated by that class when asked to serialize itself.</p>
<p>A Property&lt;O&gt; that is restricted to holding <em>exactly one</em> object of type O is called a "one-object property". It could be represented in XML as </p><div class="fragment"><div class="line">&lt;prop_name&gt; &lt;OTypeName&gt; OContents &lt;/OTypeName&gt; &lt;/prop_name&gt;</div></div><!-- fragment --><p> but we allow a more compact representation for one-object properties: </p><div class="fragment"><div class="line">&lt;OTypeName name=<span class="stringliteral">&quot;prop_name&quot;</span>&gt; OContents &lt;/OTypeName&gt;</div></div><!-- fragment --><p> In the one-object case it is also permissible for the property to be unnamed, in which case it may be referenced as though its name were the same as the object type name, and there is no separate "name" attribute. The XML representation for an unnamed property is just: </p><div class="fragment"><div class="line">&lt;OTypeName&gt; OContents &lt;/OTypeName&gt;</div></div><!-- fragment --><p> On input, if a name attribute is seen for an unnamed property it is ignored; only the object type name tag matters in the unnamed case. Note that only one-object properties can be unnamed, and no single OpenSim object can have more than one unnamed property of the same type.</p>
<h3>Property attributes</h3>
<p>In addition to the name and list of values, every property has the following attributes:</p><ul>
<li>A comment string, provided at the time the property is created.</li>
<li>The minimum and maximum number of values allowed.</li>
<li>A "used default value" flag.</li>
</ul>
<p>The "used default value" flag specifies that the value stored with this property was taken from a default object and not subsequently changed. A property with this flag set is not written out when a model is serialized.</p>
<h3>How to declare properties in your class declaration</h3>
<p>Properties are maintained in a <a class="el" href="classOpenSim_1_1PropertyTable.html" title="A property table is the container that an OpenSim Object uses to hold its properties (each derived fr...">PropertyTable</a> by OpenSim's <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> base class that is used for all serializable objects. Do not create Property objects directly; instead, use the provided macros to declare them in the class declarations for objects derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. These macros should appear in the header file near the top of your class declaration. Comments that should appear in the generated Doxygen documentation as well as in XML files should be in the comment string; if you have a comment that should appear in Doxygen documentation but not in XML, then you can place it in a Doxygen comment just above the line where you declare your property.</p>
<p><b>Naming conventions:</b> OpenSim property names should use lower case letters with <code>words_separated_by_underscores</code>. In contrast, OpenSim object types begin with a capital letter and use camel case, that is, <code>MixedUpperAndLowerLikeThis</code>. This prevents any possible collisions between property names and object types, allowing both to be used as XML tag identifiers with no conflicts.</p>
<p>These are the most common forms of property declaration. Click on the macro names below for more information. </p><div class="fragment"><div class="line"><span class="comment">// Exactly one value required; this is the basic property type.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a63b73d3f31b4fabb621028261ef63bd7">OpenSim_DECLARE_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// Zero or one value only.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#ac2050f2bbad9dde01a8ba58a4099bcc7">OpenSim_DECLARE_OPTIONAL_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// Zero or more values.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#ace0672f7b1b1864f20f827549904e26a">OpenSim_DECLARE_LIST_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div></div><!-- fragment --><p> In the above, T may be a simple type S or object type O. In the case of a single-value property where type T is a type derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> (i.e., T=O), you can declare the property to be unnamed and instead use the class name of the object type O to identify the property: </p><div class="fragment"><div class="line"><span class="comment">// Exactly one value of object type O required.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#abddd12d20ea11b5fbbed0f0115423252">OpenSim_DECLARE_UNNAMED_PROPERTY</a>(O, <span class="stringliteral">&quot;property description&quot;</span>);</div></div><!-- fragment --><p> Only one unnamed property of a particular object type O may be declared in any given <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.</p>
<p>Finally, for list properties you can declare restrictions on the allowable list length: </p><div class="fragment"><div class="line"><span class="comment">// List must contain exactly listSize (&gt; 0) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a5f19334ae8d23219043dbc835aede6ff">OpenSim_DECLARE_LIST_PROPERTY_SIZE</a>(name, T, listSize, </div><div class="line">                                   <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// List must contain at least minSize (&gt; 0) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a04e9ee4d251db381f48929f172bdf214">OpenSim_DECLARE_LIST_PROPERTY_ATLEAST</a>(name, T, minSize, </div><div class="line">                                      <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// List must contain at most maxSize (&gt; 0) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a3491426fb9c7078df400aa5b6f81f254">OpenSim_DECLARE_LIST_PROPERTY_ATMOST</a>(name, T, maxSize, </div><div class="line">                                     <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// List must contain between minSize (&gt; 0) and maxSize (&gt;minSize) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a16288ac5906b92edf9f18f6d1c65bbf5">OpenSim_DECLARE_LIST_PROPERTY_RANGE</a>(name, T, minSize, maxSize, </div><div class="line">                                    <span class="stringliteral">&quot;property description&quot;</span>);</div></div><!-- fragment --><p> Here is an example of an object declaring two properties: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ActuatorWorkMeter : <span class="keyword">public</span> ModelComponent {</div><div class="line">OpenSim_DECLARE_CONCRETE_OBJECT(ActuatorWorkMeter, ModelComponent);</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line"><span class="comment">// PROPERTIES</span></div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line">    <a class="code" href="classOpenSim_1_1Property.html#a63b73d3f31b4fabb621028261ef63bd7">OpenSim_DECLARE_PROPERTY</a>(actuator_name, std::string,</div><div class="line">        <span class="stringliteral">&quot;The name of the actuator whose work use will be calculated.&quot;</span>);</div><div class="line">    <a class="code" href="classOpenSim_1_1Property.html#a63b73d3f31b4fabb621028261ef63bd7">OpenSim_DECLARE_PROPERTY</a>(initial_actuator_work, <span class="keywordtype">double</span>,</div><div class="line">        <span class="stringliteral">&quot;Initial value for work; normally zero.&quot;</span>);</div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line"><span class="comment">// PUBLIC METHODS</span></div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line">    ...</div><div class="line">};</div></div><!-- fragment --><p> <br />
</p><h3>How to construct properties in your constructors</h3>
<p>The constructors for your Object-derived class are required to construct and initialize the properties to whatever default values you want them to have. The above macros will have generated for each property a method for this purpose. If your property is named <em>prop_name</em>, then the method will be called constructProperty_<em>prop_name</em>(). (In the case of unnamed properties, the object type serves as <em>prop_name</em>.) The initial value is provided as an argument, which is optional for those properties that are allowed to contain a zero-length value list. Here are the various types of generated construction methods: </p><div class="fragment"><div class="line"><span class="comment">// Construct and initialize a single-valued property containing type T.</span></div><div class="line"><span class="keywordtype">void</span> constructProperty_prop_name(<span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="comment">// Construct a property with a zero-length value list. </span></div><div class="line"><span class="keywordtype">void</span> constructProperty_prop_name();</div><div class="line"><span class="comment">// Construct a list property, initializing from a container.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>Container&gt;</div><div class="line"><span class="keywordtype">void</span> constructProperty_prop_name(<span class="keyword">const</span> Container&lt;T&gt;&amp; valueList);</div></div><!-- fragment --><p> The first form above is generated for basic, optional, and unnamed properties. The second, uninitialized form is generated for optional, unrestricted list, and list "atmost" properties, since those can accept a zero-element value list. The last form is generated for all list properties, regardless of size restriction; a runtime check verifies that size restrictions are met. That form accepts any container type that supports a size() method and random access element selection with operator[], such as std::vector&lt;T&gt;, OpenSim::Array&lt;T&gt;, or SimTK::Array_&lt;T&gt;.</p>
<p>The above methods are conventionally collected into a private method of each object class called <code>constructProperties()</code>. This method is then invoked from every constructor, <em>except</em> the copy constructor (which you normally should let the compiler generate, but see below).</p>
<h4>Copy constructor and copy assignment operator</h4>
<p>Your best bet is to use the compiler-generated default copy constructor and default copy assignment operator that you get whenever you leave these methods undefined. If you do that, all your properties and their associated local data will be copied automatically. It is worth some effort to design your objects so that their data members can copy and assign themselves correctly; you might find SimTK::ReferencePtr&lt;T&gt; and SimTK::ClonePtr&lt;T&gt; useful for getting pointer members to behave themselves properly.</p>
<p>However, if you do have to write your own copy constructor and copy assignment operator (and if you write one you must write the other also), the property table will still have been copied properly by your superclass, it is only the local property indices that you have to deal with. For that, each property has defined a method like: </p><div class="fragment"><div class="line"><span class="comment">// Copy the local data member associated with property prop_name.</span></div><div class="line"><span class="keywordtype">void</span> copyProperty_prop_name(<span class="keyword">const</span> Self&amp; source);</div></div><!-- fragment --><p> In the above, <code>Self</code> is the type of the object being defined and <code>source</code> is the argument that was passed to the containing copy constructor or copy assignment operator.</p>
<h3>Runtime access to property values</h3>
<p>The property declaration macros also generate per-property methods for getting access to property values or the Property objects themselves. These inline methods are very fast and can be used whenever you need access to a property value. The following are generated for single-valued property types, including the basic, optional, and unnamed properties: </p><div class="fragment"><div class="line"><span class="comment">// Get a const reference to the value of a single-valued property </span></div><div class="line"><span class="comment">// named &quot;prop_name&quot; (basic, optional, unnamed properties only).</span></div><div class="line"><span class="keyword">const</span> T&amp; get_prop_name() <span class="keyword">const</span>;</div><div class="line"><span class="comment">// Same, but returns a writable reference.</span></div><div class="line">T&amp; upd_prop_name();</div><div class="line"><span class="comment">// Set the value of a single-valued property.</span></div><div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keyword">const</span> T&amp; value);</div></div><!-- fragment --><p>Additional methods are generated for list properties: </p><div class="fragment"><div class="line"><span class="comment">// Get a const reference to the i&#39;th element in a list property&#39;s value </span></div><div class="line"><span class="comment">// list.</span></div><div class="line"><span class="keyword">const</span> T&amp; get_prop_name(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;</div><div class="line"><span class="comment">// Same, but returns a writable reference.</span></div><div class="line">T&amp; upd_prop_name(<span class="keywordtype">int</span> i);</div><div class="line"><span class="comment">// Set the i&#39;th element of a list property to the given value. Only </span></div><div class="line"><span class="comment">// allowed if the list currently has at least i elements, so no gaps can</span></div><div class="line"><span class="comment">// be created with this method.</span></div><div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keywordtype">int</span> i, <span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="comment">// Use this to append one element to a list property&#39;s value list; the</span></div><div class="line"><span class="comment">// assigned index is returned.</span></div><div class="line"><span class="keywordtype">int</span> append_prop_name(<span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="comment">// Use this to set all the values of a list-valued property.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>Container&gt;</div><div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keyword">const</span> Container&lt;T&gt;&amp; valueList);</div></div><!-- fragment --><p> The last form accepts any container that has a size() method and allows element access using operator[]. Runtime checks verify that the list length is within the allowable range for the property. Note that every property is considered to have a value list (even when restricted to one element) so the indexed forms above can also be used with single-valued properties as long as the index is zero.</p>
<p>To get access to the Property object rather than one of its values, the following methods are provided: </p><div class="fragment"><div class="line"><span class="comment">// Get a const reference to the Property&lt;T&gt; object for &quot;prop_name&quot;.</span></div><div class="line"><span class="keyword">const</span> Property&lt;T&gt;&amp; getProperty_prop_name() <span class="keyword">const</span>;</div><div class="line"><span class="comment">// Same, but returns a writable reference.</span></div><div class="line">Property&lt;T&gt;&amp; updProperty_prop_name();</div></div><!-- fragment --><p>The Property&lt;T&gt; class acts as a container of values, and has the usual size(), empty(), and operator[] methods available so you can use getProperty...() above to get access to those methods. For example, to write out all the values of any property: </p><div class="fragment"><div class="line"><span class="comment">// Assumes type T can be written to a stream with operator&lt;&lt;.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; getProperty_prop_name().size(); ++i)</div><div class="line">    std::cout &lt;&lt; get_prop_name(i) &lt;&lt; std::endl;</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">OpenSim::AbstractProperty</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Michael Sherman </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa062d40d7e621c8891e2eefcd9cd6215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa062d40d7e621c8891e2eefcd9cd6215">&#9670;&nbsp;</a></span>Property() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d9596fe70f1c128d31a4034a27e175c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9596fe70f1c128d31a4034a27e175c">&#9670;&nbsp;</a></span>~Property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::~<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a940f9f9b08ec3835b625a63a2ede3a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940f9f9b08ec3835b625a63a2ede3a70">&#9670;&nbsp;</a></span>Property() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada8afb4114ae6dc828039f9473bf3f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8afb4114ae6dc828039f9473bf3f6a">&#9670;&nbsp;</a></span>Property() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7f955ce364fd5c6a031263894a77c6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f955ce364fd5c6a031263894a77c6a2">&#9670;&nbsp;</a></span>adoptAndAppendValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::adoptAndAppendValue </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new value to the end of this property's value list, taking over ownership of the supplied heap-allocated object. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a80913f153f09fa3e8a2f62f255a2c659">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a id="a8cebe3dfc74cb4f1d5158a4feb449e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cebe3dfc74cb4f1d5158a4feb449e05">&#9670;&nbsp;</a></span>appendValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::appendValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a copy of the supplied <em>value</em> to the end of this property's value list. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a80913f153f09fa3e8a2f62f255a2c659">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOpenSim_1_1Object.html#a2e09382ab2bb833eba12c081f35b5a2d">OpenSim::Object::addListProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#affef953ecb6526d5de51f8d045229d79">OpenSim::Object::addOptionalProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5">OpenSim::Object::addProperty()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a05726a6ab0bee46b8f2b07a8931fd90a">OpenSim::AbstractProperty::appendValue()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a id="a7f8d2992c9f493380aa3400a6f6ec9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8d2992c9f493380aa3400a6f6ec9a8">&#9670;&nbsp;</a></span>appendValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::appendValue </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a <em>copy</em> of the supplied <em>value</em> to the end of this property's value list. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. Note that although we accept a pointer here, we do not take over ownership. See <a class="el" href="classOpenSim_1_1Property.html#a7f955ce364fd5c6a031263894a77c6a2" title="Add a new value to the end of this property&#39;s value list, taking over ownership of the supplied heap-...">adoptAndAppendValue()</a> if you want the property to take ownership. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a80913f153f09fa3e8a2f62f255a2c659">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a id="aeeca88c50f8115970c150889b1fd1ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeca88c50f8115970c150889b1fd1ab3">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>* <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space. </p>
<p>Caller must delete the returned object when done with it. </p>

<p>Implements <a class="el" href="classOpenSim_1_1AbstractProperty.html#a2f3b26063ae74e345154c8695a7cd352">OpenSim::AbstractProperty</a>.</p>

</div>
</div>
<a id="ad23afa22d5e9e646e7da341dcee0399b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23afa22d5e9e646e7da341dcee0399b">&#9670;&nbsp;</a></span>findIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::findIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search the value list for an element that has the given <em>value</em> and return its index if found, otherwise -1. </p>
<p>This requires only that the template type T supports <a class="el" href="classOpenSim_1_1AbstractProperty.html#a26105c68088639cfac2a55206c6a9e65" title="See the equals() method for the meaning of this operator. ">operator==()</a>. This is a linear search so will take time proportional to the length of the value list. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a80913f153f09fa3e8a2f62f255a2c659">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1Property.html#ad655c37b8c73982b61714965285d4ca9">OpenSim::Property&lt; T &gt;::getValue()</a>.</p>

</div>
</div>
<a id="af4f59bebcc0e0665781b238505312667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f59bebcc0e0665781b238505312667">&#9670;&nbsp;</a></span>findIndexForName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::findIndexForName </td>
          <td>(</td>
          <td class="paramtype">const SimTK::String &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return index of passed in name if the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> contains objects that are derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, and -1 if no such <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> is found. </p>
<p>Throws an <a class="el" href="classOpenSim_1_1Exception.html" title="A class for basic exception functionality. ">Exception</a> if the List doesn't contain <a class="el" href="namespaceOpenSim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> Objects (e.g. primitive types) since these are not named. When a search is performed, it's a linear search. </p>

</div>
</div>
<a id="ac9729da476501b3fb9cfcdcf16f531e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9729da476501b3fb9cfcdcf16f531e7">&#9670;&nbsp;</a></span>getAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a concrete property of this type (Property&lt;T&gt;). </p>
<p>An exception is thrown if this is not the right type only in DEBUG mode; see <a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b" title="Return true if the given AbstractProperty references a concrete property of this type (Property&lt;T&gt;)...">isA()</a> if you need to check first. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOpenSim_1_1PropertyTable.html#abae09ea96ab8d4c987b7f41631c45016">OpenSim::PropertyTable::getProperty()</a>.</p>

</div>
</div>
<a id="a504d2d8a31105c18755a6a12a0ec955a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504d2d8a31105c18755a6a12a0ec955a">&#9670;&nbsp;</a></span>getTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html" title="This is the generic definition of Property::TypeHelper to be used whenever T does not have a speciali...">TypeHelper</a>'s <a class="el" href="classOpenSim_1_1Property.html#a504d2d8a31105c18755a6a12a0ec955a" title="Use TypeHelper&#39;s getTypeName() to satisfy this pure virtual. ">getTypeName()</a> to satisfy this pure virtual. </p>

<p>Implements <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d19ec8b81d27849e5cf0c41cdb9a4e6">OpenSim::AbstractProperty</a>.</p>

</div>
</div>
<a id="ad655c37b8c73982b61714965285d4ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad655c37b8c73982b61714965285d4ca9">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the selected value from this property's value list. </p>
<p>If the property is at most single valued then the <em>index</em> is optional and we'll behave as though index=0 were supplied. You can use the square bracket operator property[index] instead. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">OpenSim::AbstractProperty::getMaxListSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOpenSim_1_1Object.html#a1d943c0b0e76f4c1b169dc2bae88ec48">OpenSim::Object::checkPropertyValueIsInRangeOrSet()</a>, <a class="el" href="classOpenSim_1_1Object.html#adc2ab38c8cb1b159cde83a2287168f07">OpenSim::Object::checkPropertyValueIsInSet()</a>, <a class="el" href="classOpenSim_1_1Object.html#a5d51ce53f270d5f6edaec4b7e0757a5a">OpenSim::Object::checkPropertyValueIsPositive()</a>, <a class="el" href="classOpenSim_1_1Property.html#ad23afa22d5e9e646e7da341dcee0399b">OpenSim::Property&lt; T &gt;::findIndex()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a9635d07249fbd05ce8c1fe0d751aec35">OpenSim::AbstractProperty::getValue()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a3d7af7802a58607ab6a41c73e23f916c">OpenSim::Property&lt; T &gt;::operator[]()</a>.</p>

</div>
</div>
<a id="a7a234feb91cb9e416ceaaff20586b17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a234feb91cb9e416ceaaff20586b17b">&#9670;&nbsp;</a></span>isA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::isA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> references a concrete property of this type (Property&lt;T&gt;). </p>
<p>Note that for this to return true, the type T must be exactly the type used when the concrete property was allocated; it is not sufficient for T to be a more general base type from which the actual type was derived. </p>

</div>
</div>
<a id="aa9c23999672ed5ec0d74d140a67e89ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c23999672ed5ec0d74d140a67e89ea">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a value of type T sets the value of this single-valued property to a copy of the supplied <em>value</em>; not allowed for a list property. </p>
<p>This does not invoke the assignment operator on the existing value. Instead, the value list is cleared and then replaced by the new value. This is synonymous with setValue(value). </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a id="af3f1f6ba165cb5bd24cab98a22a8076c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f1f6ba165cb5bd24cab98a22a8076c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container. </p>
<p>The current value list is cleared before the assignment. This is synonymous with setValue(valueList). </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a id="ae29e9433e3c00ddae30ae629b04fb0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29e9433e3c00ddae30ae629b04fb0a8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05a9dcdfb4969704946a19931f0bf252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a9dcdfb4969704946a19931f0bf252">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d7af7802a58607ab6a41c73e23f916c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7af7802a58607ab6a41c73e23f916c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to one of the values in the value list. </p>
<p>This will throw an exception if the index does not refer to an already-existing value. This operator is synonymous with getValue(i). </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1Property.html#ad655c37b8c73982b61714965285d4ca9">OpenSim::Property&lt; T &gt;::getValue()</a>.</p>

</div>
</div>
<a id="a567d26efb726367aca90f2534b032352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567d26efb726367aca90f2534b032352">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a writable reference to one of the values in the value list. </p>
<p>This will throw an exception if the index does not refer to an already-existing value. This operator is synonymous with updValue(i). </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1Property.html#ae597340fa1da9385439bbebf91a6a92a">OpenSim::Property&lt; T &gt;::updValue()</a>.</p>

</div>
</div>
<a id="a648a457cc3c192dcb68a97a6e179e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648a457cc3c192dcb68a97a6e179e2db">&#9670;&nbsp;</a></span>removeValueAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::removeValueAtIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove specific entry of the list at index. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5f536d90bb3e5f400e540db08511f096">OpenSim::AbstractProperty::getMinListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a80913f153f09fa3e8a2f62f255a2c659">OpenSim::AbstractProperty::getNumValues()</a>.</p>

</div>
</div>
<a id="a3a8b68f9fa4cf67c5b9d681b4499d63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8b68f9fa4cf67c5b9d681b4499d63e">&#9670;&nbsp;</a></span>setValue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the i'th value list element with a copy of the given <em>value</em>. </p>
<p>The index i must be between 0 and the current list length, meaning it is OK to refer one element past the last element. In that case the new <em>value</em> is appended to the list using <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05" title="Append a copy of the supplied value to the end of this property&#39;s value list. ">appendValue()</a>, which will throw an exception if the list is already at its maximum allowable size. In the case where index i refers to an existing element, a simple property will assign a new value to the existing element but an object property will delete the old object and replace it with a <a class="el" href="classOpenSim_1_1Property.html#aeeca88c50f8115970c150889b1fd1ab3" title="Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space...">clone()</a> of the new one &ndash; it will <em>not</em> invoke the old object's assignment operator. That means that the concrete object type may be changed by this operation, provided it is still a type derived from object type T. If you want to invoke the existing value's assignment operator, use updValue(i) rather than setValue(i). </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">OpenSim::Property&lt; T &gt;::appendValue()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a80913f153f09fa3e8a2f62f255a2c659">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOpenSim_1_1Property.html#aa9c23999672ed5ec0d74d140a67e89ea">OpenSim::Property&lt; T &gt;::operator=()</a>, and <a class="el" href="classOpenSim_1_1Property.html#aa92e55af5a211a210900438d858a481a">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a id="aa92e55af5a211a210900438d858a481a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92e55af5a211a210900438d858a481a">&#9670;&nbsp;</a></span>setValue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a new value for a single-valued property. </p>
<p>The current value (if any) is replaced, and size()==1 afterwards. An exception is thrown if this is a list property. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a7f70dd571c232d2a9f7ab64406499e88">OpenSim::AbstractProperty::isListProperty()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a id="a00355490194329012905b3407917fe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00355490194329012905b3407917fe9e">&#9670;&nbsp;</a></span>setValue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container. </p>
<p>The current value is cleared before the assignment. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5ec8c00426c6841139be00515e749713">OpenSim::AbstractProperty::clear()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5f536d90bb3e5f400e540db08511f096">OpenSim::AbstractProperty::getMinListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a id="ac416f4ac135fcadc1a35b47b3cd36f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac416f4ac135fcadc1a35b47b3cd36f0b">&#9670;&nbsp;</a></span>updAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::updAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a writable concrete property of this type (Property&lt;T&gt;). </p>
<p>An exception is thrown if this is not the right type only in DEBUG mode; see <a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b" title="Return true if the given AbstractProperty references a concrete property of this type (Property&lt;T&gt;)...">isA()</a> if you need to check first. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a8da380c1f75c9f87cfd930e773aed4ad">OpenSim::AbstractProperty::getName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOpenSim_1_1PropertyTable.html#aec71e379bcfc07db394c4ca6c300d2f4">OpenSim::PropertyTable::updProperty()</a>.</p>

</div>
</div>
<a id="ae597340fa1da9385439bbebf91a6a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae597340fa1da9385439bbebf91a6a92a">&#9670;&nbsp;</a></span>updValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::updValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the selected value from this property's value list. </p>
<p>If the property is at most single valued then the <em>index</em> is optional and we'll behave as though index=0 were supplied. You can use the square bracket operator property[index] instead. </p>

<p class="reference">References <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac8e6da1b1f16d4e9c230487193979298">OpenSim::AbstractProperty::getMaxListSize()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOpenSim_1_1Property.html#a567d26efb726367aca90f2534b032352">OpenSim::Property&lt; T &gt;::operator[]()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a08cd08421dc135dface6cb9fb3d1e1c1">OpenSim::AbstractProperty::updValue()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenSim/Common/AbstractProperty.h</li>
<li>OpenSim/Common/Property.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceOpenSim.html">OpenSim</a></li><li class="navelem"><a class="el" href="classOpenSim_1_1Property.html">Property</a></li>
    <li class="footer">Generated on Tue Mar 5 2024 17:48:59 for API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
